#pragma once
#include <Windows.h>

namespace assembly{
	
	inline byte shellcode[] =
	{
		0x9C, // pushf (save flags)
		0x50, // push rax
		0x53, // push rbx
		0x51, // push rcx
		0x52, // push rdx
		0x56, // push rsi
		0x57, // push rdi
		0x41, 0x50, // push r8
		0x41, 0x51, // push r9
		0x41, 0x52, // push r10
		0x41, 0x53, // push r11
		0x41, 0x54, // push r12
		0x41, 0x55, // push r13
		0x41, 0x56, // push r14
		0x41, 0x57, // push r15


		0x48, 0xB8, 0xFF, 0x00, 0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0xFF,// mov rax,0xff00efbeadde00ff [entry-address-place-holder]
		0x48, 0x31, 0xD2, // xor rdx,rdx (clean register)
		0x48, 0x83, 0xC2, 0x01, // add rdx,byte
		0x48, 0x83, 0xEC, 0x28, // sub rsp,0x28 (align the stack and shadow space allocation)
		0xFF, 0xD0, // call rax
		0x48, 0x83, 0xC4, 0x28, // add rsp,0x28
		0x48, 0xB8, 0xFF, 0x00, 0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0xFF, // mov rax,0xff00efbeadde00ff [original-iat-ptr-address-place-holder]
		0x48, 0xBA, 0xFF, 0x00, 0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0xFF, // mov rdx,0xff00efbeadde00ff [iat-func-address-place-holder]
		0x48, 0x89, 0x10, // mov [rax],rdx (write address from rdx to memory at rax)
	    0xC6, 0x05, 0x0D, 0x00, 0x00, 0x00, 0x01, // mov byte ptr [rip+0xd], 1 (0xd == dec 13)
	    0x48, 0x8D, 0x05, 0x00, 0x00, 0x00, 0x00, // lea rax,[rip]
	    0x48, 0x8D, 0x40, 0x08, // lea rax,[rax+8]
		0xFF, 0xE0, // jmp rax
		0x00, 0x00, // add BYTE PTR [rax],al
		

		0x41, 0x5F, // pop r15
		0x41, 0x5E, // pop r14
		0x41, 0x5D, // pop r13
		0x41, 0x5C, // pop r12
		0x41, 0x5B, // pop r11
		0x41, 0x5A, // pop r10
		0x41, 0x59, // pop r9
		0x41, 0x58, // pop r8
		0x5F, // pop rdi
		0x5E, // pop rsi
		0x5A, // pop rdx
		0x59, // pop rcx
		0x5B, // pop rbx
		0x58, // pop rax
		0x9D, // popf (restore flags)


		// call original function?
		0x48, 0x89, 0xE5, // mov rbp,rsp
		0x48, 0x8B, 0x6D, 0x00, // mov rbp,[rbp]
		0x48, 0x8D, 0x6D, 0xFA, // lea rbp,[rbp-6] <- this has our call instruction
		0xFF, 0xD5, // call rbp
		0xC3 // ret
	};

	// this is treated as an int
	enum Shell_Address_Location
	{
		DLL_ENTRY_POINT = 25,
		IAT_FUNCTION_PTR = 52,
		IAT_ORIGINAL_FUNCTION_ADDRESS = 62,
		SIGNAL_BYTE_OFFSET = 93
	};

	template<class T>
	inline void shellcode_insert_address(Shell_Address_Location location, T address) noexcept
	{
		*reinterpret_cast<T*>(shellcode + location) = address;
	}

	inline std::uintptr_t signal_byte_offset(void* shellcode_ptr_address) noexcept
	{
		return reinterpret_cast<std::uintptr_t>(shellcode_ptr_address) + SIGNAL_BYTE_OFFSET;
	}

};



